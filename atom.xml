<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://BolinWu-Gridea.github.io</id>
    <title>Bolin Wu</title>
    <updated>2021-02-26T15:35:31.011Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://BolinWu-Gridea.github.io"/>
    <link rel="self" href="https://BolinWu-Gridea.github.io/atom.xml"/>
    <subtitle>Data Science Blog
</subtitle>
    <logo>https://BolinWu-Gridea.github.io/images/avatar.png</logo>
    <icon>https://BolinWu-Gridea.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bolin Wu</rights>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://BolinWu-Gridea.github.io/post/test/</id>
        <link href="https://BolinWu-Gridea.github.io/post/test/">
        </link>
        <updated>2021-02-26T08:27:36.000Z</updated>
        <content type="html"><![CDATA[<p>test</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Classification of Baseball Player Technical Statistics by Decision Tree and Random Forest]]></title>
        <id>https://BolinWu-Gridea.github.io/post/2020-02-18-DecisionTree/</id>
        <link href="https://BolinWu-Gridea.github.io/post/2020-02-18-DecisionTree/">
        </link>
        <updated>2021-02-09T09:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Tree-based methods are conceptually easy to comprehend and they render advantages like easy visualization and data-preprocessing. It is a powerful tool for classification. In this post I will introduce how to classify baseball player technical statistics by  Decision Tree and Random Forest from algorithm coding to  package usage.</p>
<h2 id="content">Content:</h2>
<ol>
<li>Showing the algorithm of Decision Tree by R, which including tree splitting, tree grwoing, bagging, prediction, etc.</li>
<li>Runing Random Forest and XGBoost with the help of <strong>randomForest</strong> package</li>
</ol>
<h2 id="reference">Reference:</h2>
<ul>
<li><a href="https://web.stanford.edu/~hastie/ElemStatLearn/">The Elements of Statistical Learning: Data Mining, Inference, and Prediction</a>  by Trevor Hastie et al.</li>
<li>Mans Magnusson (2020). uuml: R Content for the Introduction to Machine Learning. Course at Uppsala University. R package version 0.2.0.</li>
</ul>
<h1 id="decision-tree">Decision Tree</h1>
<h2 id="data-pre-processing">Data Pre-processing</h2>
<p>First, we need to lead the dataset Hitters provided in the refereced <a href="https://github.com/MansMeg/IntroML/tree/master/rpackage">uuml</a> package. This dataset consists of the salary of many baseball players and their relevant technical statistics. <br>
Here we assume that we only care about three columns:&quot;Years&quot;, &quot;Hits&quot; and &quot;Salary&quot;. The missing values are imputed by listwise deletion. And we set the first 30 ovservations as test set and the rest as training set.</p>
<pre><code class="language-r"># install relevant packages
# remotes::install_github(&quot;MansMeg/IntroML&quot;,subdir = &quot;rpackage&quot;)
# install.packages(&quot;randomForest&quot;)
# install.packages(&quot;xgboost&quot;)

# loead the packages                     
library(xgboost)
library(randomForest)
# load the data
library(uuml)
data(&quot;Hitters&quot;)
# In the task we only care about three columns:&quot;Years&quot;, &quot;Hits&quot; and &quot;Salary&quot;
# and we need to excluede the NA values
# So we need to pre-process the data
Hitters = Hitters[,c(&quot;Years&quot;, &quot;Hits&quot;,&quot;Salary&quot;)]

# get rid of NA
Hitters &lt;- Hitters[complete.cases(Hitters),]

# set aside test set and training set
X_test &lt;- Hitters[1:30, c(&quot;Years&quot;, &quot;Hits&quot;)]
y_test &lt;- Hitters[1:30, c(&quot;Salary&quot;)]
X_train &lt;- Hitters[31:nrow(Hitters), c(&quot;Years&quot;, &quot;Hits&quot;)]
y_train &lt;- Hitters[31:nrow(Hitters), c(&quot;Salary&quot;)]

</code></pre>
<h2 id="tree-splitting">Tree Splitting</h2>
<p>Now let us see how to do the first split. Please note that here does not involve tree growing.</p>
<h3 id="concept">Concept</h3>
<p>The alforithm we will use is from the referenced book <em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em> (ESL), P307. We are seeking to splitting variable j and split point s that meet:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>s</mi></mrow></msub><mo>[</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>c</mi><mn>1</mn></mrow></msub><munder><mo>∑</mo><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>R</mi><mn>1</mn></msub><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>s</mi><mo>)</mo></mrow></munder><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mi>c</mi><mn>1</mn></msub><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><msub><mi>c</mi><mn>2</mn></msub></msub><munder><mo>∑</mo><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>R</mi><mn>2</mn></msub><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>s</mi><mo>)</mo></mrow></munder><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mo>)</mo><mn>2</mn></msup><mo>]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
min_{j,s} [min_{c1} \sum_{x_{i}\in R_{1}(j,s)}(y_{i} - c_{1})^{2} + min_{c_{2}} \sum_{x_{i} \in R_{2}(j,s)}(y_{i} - c_{2})^{2} ]
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.86601em;vertical-align:-1.183005em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.683005em;"><span style="top:-3.683005em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.00773em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">s</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.00773em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">s</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.183005em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Where the inner minimization with regard to j and s is solved by :</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mover accent="true"><msub><mi>c</mi><mn>1</mn></msub><mo>^</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>a</mi><mi>v</mi><mi>e</mi><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>R</mi><mn>1</mn></msub><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>s</mi><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mover accent="true"><msub><mi>c</mi><mn>2</mn></msub><mo>^</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>a</mi><mi>v</mi><mi>e</mi><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>R</mi><mn>2</mn></msub><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>s</mi><mo>)</mo><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\hat{c_{1}} &amp;= ave (y_{i}| x_{i} \in R_{1} (j,s)) \\
\hat{c_{2}} &amp;= ave (y_{i}| x_{i} \in R_{2} (j,s))
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>By first glance, you may get confused by what do those equations mean. Let us use a part of the data to make an illustration:</p>
<pre><code class="language-r"># use a size of 20
X_check &lt;- Hitters[31:50, c(&quot;Years&quot;, &quot;Hits&quot;)]
y_check &lt;- Hitters[31:50, c(&quot;Salary&quot;)]

head(X_check)

##           Years   Hits
## -Bob Melvin	2	60
## -BillyJo Robidoux	2	41
## -Bill Schroeder	4	46
## -Chris Bando	6	68
## -Chris Brown	3	132
## -Carmen Castillo	5	57

</code></pre>
<p>Essentially, what they do can be explained by the following three steps:</p>
<ol>
<li>Let j grind over all the variables of the dataset, which in our case is 2 variables <strong>Years</strong> and <strong>Hits</strong>. Let s grind over all the values of jth variable. For example, given the sample data above when j = 1 (Years), s will grind from year = 2 (Bob Melvin) to the year of last player.</li>
<li>Allocate each observation according to the given j and s into two groups. And then calculate the mean value of each group, $$\hat{c_{1}}$$ and $$\hat{c_{2}}$$. Get the within group scatters by using the function in the min() of the first equation above.</li>
<li>Return the j and s that give the smallest within group scatter.</li>
</ol>
<p>This process can be also called <strong>greedy method</strong>, because we are grinding all the possible values and return the most ideal result.</p>
<h3 id="code">Code</h3>
<p>To illustrate with R code, we will implement a function that takes data set X, the label y, and a minimal leaf size l. This function will give four outputs: The region that each observation belongs to (R1 and R2), splitting variable j and splitting point s.</p>
<pre><code class="language-r">tree_split = function(X,y,l){
  # store the split point
  S = matrix(NA,nrow = nrow(X), ncol = ncol(X))
  # store the sum of square
  SS = matrix(NA,nrow = nrow(X), ncol = ncol(X))
  for (j in 1:ncol(X)) {
    for (k in 1:nrow(X)) {
      # use the data point as split point
      s = X[k,j]
      # get the size in each leaf
      R1_size = length(  which(X[,j] &lt; s) )
      R2_size = length(  which(X[,j] &gt;= s) )
      # proceed if the size of leaf is bigger than the minimum l
      if (R1_size &gt;= l &amp; R2_size &gt;=l) {
        # 2.1.3
         c1 = mean( y[which(X[,j] &lt; s)] )
         # 2.1.4
         c2 = mean( y[which(X[,j] &gt;= s)] )
         # 2.1.5
         SS[k,j] =  sum( (y[which(X[,j] &lt; s)] - c1)^2 ) +
           sum((y[which(X[,j] &gt;= s)] - c2)^2)
      } else{
        # if the leaf is smaller than the minimum, then set to inf
        SS[k,j] = Inf
      }
      S[k,j] = s
    }
  }
  # find the index of Matix with smallest value
  j = which(SS == min(SS), arr.ind = TRUE)[1,2];
  s = X[which(SS == min(SS), arr.ind = TRUE)[1,1],j];
  R1 = which(X[,j] &lt; s);
  R2 = which(X[,j] &gt;= s)
  return(list(j = j,
               s = s,
               R1 = R1,
               R2 = R2
              , SS = min(SS)
              )
              )
  }

</code></pre>
<p>Then check with the sample data, assuming the minimal leaf size to be 5:</p>
<pre><code class="language-r">
tree_split(X_check, y_check, l = 5)

$j
col
  1

$s
[1] 6

$R1
 [1]  1  2  3  5  6  9 13 16 18 19

$R2
 [1]  4  7  8 10 11 12 14 15 17 20

$SS
[1] 1346633

</code></pre>
<p>The results seem to be reasonable. What about the first split for the whole training data?</p>
<pre><code class="language-r">tree_split(X_train , y_train , l = 5 )

$j
col
  1

$s
[1] 5

$R1
 [1]   1   2   3   5   9  13  16  18  19  21  22
[12]  28  30  36  38  40  41  42  45  51  55  57
[23]  73  75  78  79  80  88  89  94  96  99 100
[34] 102 104 107 113 114 118 119 121 128 130 133
[45] 134 138 139 141 142 143 145 146 147 149 151
[56] 152 155 157 167 178 180 183 184 185 187 191
[67] 192 193 194 197 198 199 204 206 210 211 216
[78] 220 222 227 228

$R2
  [1]   4   6   7   8  10  11  12  14  15  17  20
 [12]  23  24  25  26  27  29  31  32  33  34  35
 [23]  37  39  43  44  46  47  48  49  50  52  53
 [34]  54  56  58  59  60  61  62  63  64  65  66
 [45]  67  68  69  70  71  72  74  76  77  81  82
 [56]  83  84  85  86  87  90  91  92  93  95  97
 [67]  98 101 103 105 106 108 109 110 111 112 115
 [78] 116 117 120 122 123 124 125 126 127 129 131
 [89] 132 135 136 137 140 144 148 150 153 154 156
[100] 158 159 160 161 162 163 164 165 166 168 169
[111] 170 171 172 173 174 175 176 177 179 181 182
[122] 186 188 189 190 195 196 200 201 202 203 205
[133] 207 208 209 212 213 214 215 217 218 219 221
[144] 223 224 225 226 229 230 231 232 233

$SS
[1] 38464163


</code></pre>
<p>The fist split variate is j =1, which is year. The value is 5. If year is smaller than 5, then the observations go to R1, otherwise go to R2.</p>
<h2 id="tree-growing">Tree Growing</h2>
<p>In this part, I will first show the code and then illustrate it.</p>
<h3 id="code-2">Code</h3>
<p>Conceptually, tree growing is easy to understand: we looping pre-defined tree splitting until the generated leaves are so small that can not be further splitted (leaf size &lt; 2l). <br>
However, it is a bit difficult to implement tree growing by coding. Here I will make a function that takes same X,y, and l. It returns a data frame including j, s, gamma, R1_i and R2_i. Gamma is a metric of within group scatter. The R1_i and R2_i indicates which row of data frame to go next.</p>
<pre><code class="language-r">max_num_leaf = 7
#this does not affact the output, just set the max depth of the tree, the redundant part will show NA
grow_tree = function(X,y,l){
  # make the matrix to store the data
  S = matrix(NA,nrow = max_num_leaf, ncol = nrow(X))
  j = matrix(NA,nrow = max_num_leaf, ncol = 1)
  s = matrix(NA,nrow = max_num_leaf, ncol = 1)
  gamma_m = matrix(NA,nrow = max_num_leaf, ncol = 1)
  R1_i = rep(NA, length = max_num_leaf);
  R2_i = rep(NA, length = max_num_leaf)
  # the initial value
  S[1,] = c(1 : nrow(X))
  M = 1
  m = 1

  while (m &lt;= M ) {
      # loop until the size is too small to be splitted
     if ( length(S[m,][!is.na(S[m,])])&gt;= (2*l) ){
         # given a specific m:
         # get leaf size after split
       len_col = length((tree_split(X[S[m,],], y[S[m,]], l = l)$R1))
       S[M+1,1:len_col ] = tree_split(X[S[m,],], y[S[m,]], l = l)$R1
       len_col = length((tree_split(X[S[m,],], y[S[m,]], l = l)$R2))
       S[M+2,1:len_col] = tree_split(X[S[m,],], y[S[m,]], l = l)$R2
          # get the split variable and point
       j[m] = tree_split(X[S[m,],], y[S[m,]], l = l)$j
       s[m] = tree_split(X[S[m,],], y[S[m,]], l = l)$s
          # move on
       R1_i[m] = M+1 ; R2_i[m] = M + 2
       M = M +2
     } else {
         # when the size is too small, just return gamma, stop increasing M
       gamma_m [m]= mean( y[S[m,]], na.rm = T )
     }
    m = m + 1

  }
  return(data.frame( j = j, s = s , R1_i=R1_i, R2_i = R2_i, gamma = gamma_m ))
}

</code></pre>
<h3 id="explanation">Explanation</h3>
<p>Here my code may seem a bit too much. I believe that different people will have different approaches to build the algorithm and if you who are reading this post have a neater way please let me know, thank you 😃 <br>
Instead of explaining the my code line by line, I would like to explain the general concept with the help of my scrach. Sorry if it is a bit ugly.</p>
<figure>
  <img src="{{ site.url }}{{ site.baseurl }}/images/DecisionTreeFig/ugly_illustration.jpeg" alt="none" style="width:100%">
  <figcaption> An ugly scratch </figcaption>
</figure>
<p>The key is to use m (green) and M (yellow). The m denotes the index of splitted leaves, the M denotes the total number of leaves given an iteration. Therefore, as long as when the size of leaf m is bigger than 2l, m increases by 1 step while M goes by 2 steps per iteration (since there are two new leaves after each split). <br>
It is kind of like m is chasing M, and M stops when leaves stop growing and m stops when it catches M. Every time when m goes one step, it activates tree splitting function and gathers useful infomation.</p>
<p>Let us try out with the sample data:</p>
<pre><code class="language-r">tr = grow_tree(X_check,y_check,l = 5)
tr

## j   s  R1_i R2_i gamma
## 1	6	2	3	 NA
## 1	4	4	5	 NA
## 2	102	6	7	 NA
## NA	NA	NA	NA	 317
## NA	NA	NA	NA	 496
## NA	NA	NA	NA	 274
## NA	NA	NA	NA	 539

</code></pre>
<p>This data frame can be regarded as a &quot;map&quot;. For example, for observation <strong>Bob Melvin; year = 2 hits = 60</strong>, firstly since year&lt;6, it follows R2_i = 3, going to 3rd row of the data frame. Secondly, since hits&lt;102, it follows R2_i = 7, going to the 7th row. Thirdly, since there are only NA for indicating next step, the 7th row is its destination.</p>
<h2 id="prediction">Prediction</h2>
<p>Finally, we are at an exciting part, predicing a new observation given our pre-trained decision tree!</p>
<p>The basic idea of prediction is following the output dataframe of the tr. As is mentioned above, R1_i and R2_i indicates the row of the dataframe to go next like a map. It is stopped until the row shows up NA for the first 4 columns.</p>
<p>This function is to predict the classification gamma of new observations.</p>
<pre><code class="language-r">predict_with_tree = function(newdata, tree){

 pred = matrix(NA,nrow =1 , ncol = ncol(newdata))
 for (i in 1: nrow(newdata)) {
   # start with m =1, the first row
   m =1 ; s = tree[m,2] ; j = tree[m,1]
   while (!is.na(tree[m,1])) {
     if (newdata[i,j] &lt;s) { # follow R1_i
       m = tree[m,3];s = tree[m,2] ; j = tree[m,1]

     }else{# follow R2_i
       m = tree[m,4];s = tree[m,2] ; j = tree[m,1]
     }
     pred[i] = tree[m,5]
   }
 }
 return(pred)
}

</code></pre>
<p>Let us pre:</p>
<pre><code class="language-r">X_new &lt;- Hitters[51:52, c(&quot;Years&quot;, &quot;Hits&quot;)]
y_new &lt;- Hitters[51:52, c(&quot;Salary&quot;)]
predict_with_tree(newdata = X_new, tree = tr)

##     [,1] [,2]
## [1,]  317  496
</code></pre>
<p>The gamma of first observation is 317 and the second is 396.</p>
<p>What is the mean square error on the test set for a tree trained on the whole training data?</p>
<pre><code class="language-r"># set a large maximum tree depth
max_num_leaf = 50

# since we have more observations than the check data
# set the minimum leaf size = 10
tr = grow_tree(X_train,y_train,l = 10)
pred_tr = predict_with_tree(newdata = X_test, tree = tr)

MSE = mean((pred_tr - y_test) ^2 )
cat(&quot;MSE =&quot;,MSE)

## MSE = 78395.21
</code></pre>
<h1 id="bagging">Bagging</h1>
<h2 id="concept-2">Concept</h2>
<p>The basic idea of bagged tree regression is that we draw with replacement a random sample of N units from the original sample and fit a prediction, then we repeat it B times. In the end we weigh together the B predictions and derive the final prediction. The picture on P285, ESL tells us that as the number of Bootstrap samples goes greater, the test error goes smaller then it tends to be a constant which is smaller than the original tree.</p>
<figure>
  <img src="{{ site.url }}{{ site.baseurl }}/images/DecisionTreeFig/P285_BagComparison.jpg" alt="none" style="width:100%">
  <figcaption> Figure from P285, ESL </figcaption>
</figure>
<h2 id="code-3">Code</h2>
<pre><code class="language-r">bagged_tree = function(Xtrain, Ytrain, l, B,Xtest){
  sizeN = nrow(Xtrain)
  # store the predictions
  bagged_pred = matrix(NA, nrow = B, ncol = nrow(Xtest))
  for (i in (1:B)) {
    # bootstrap sample
    random_draw = sample( c(1:sizeN ), size = sizeN ,replace = T )
    bagged_tr = grow_tree(Xtrain[random_draw,],Ytrain[random_draw],l)
    bagged_pred_tr = predict_with_tree(newdata = Xtest, tree = bagged_tr)
    bagged_pred[i,] = bagged_pred_tr
    i = i + 1
  }
  # the final prediction is the mean of the B trees prediction
  return(colMeans(bagged_pred) )
}

</code></pre>
<p>Let us see if the B goes bigger, will RMSE goes smaller:</p>
<pre><code class="language-r">
set.seed(100)
cat(&quot;B = 10, bagged tree RMSE = &quot;,sqrt (mean(( bagged_tree(X_train,y_train,l = 10,
                                               B=10,Xtest = X_test) - y_test) ^2 ) ), &quot;\n&quot;,
    &quot;B = 20, bagged tree  RMSE = &quot;,sqrt (mean(( bagged_tree(X_train,y_train,l = 10,
                                               B=20,Xtest = X_test) - y_test) ^2 ) ), &quot;\n&quot;,
    &quot;B = 30, bagged tree  RMSE = &quot;,sqrt (mean(( bagged_tree(X_train,y_train,l = 10,
                                               B=30,Xtest = X_test) - y_test) ^2 ) ), &quot;\n&quot;
    )

## B = 10, bagged tree RMSE =  312.8866
##  B = 20, bagged tree  RMSE =  309.4088
##  B = 30, bagged tree  RMSE =  295.2994
</code></pre>
<p>The RMSE goes smaller indeed.</p>
<h1 id="random-forest-and-boosting">Random Forest and Boosting</h1>
<h2 id="concept-3">Concept</h2>
<p>The idea of random forest is very similar to bagged tree model. There is only one difference that in bagged tree model, all the features in the bootstrap samples are used. But in the random forest only random subset (without replacement) of features are chosen. The random forest is supposed to give a better performance if the trees are highly correlated. <br>
The intuition of boosting is that the training of latter tree is learning from the misclassification of the previous tree. So that the next trained tree is better than the previous tree.</p>
<p>For this part, we just need to fit the data into randomForest() function. ntree controls the number of bootstrap samples. To make it comparable, I also set ntree to be 10 which is the same as the previous bagged tree regression.</p>
<h2 id="code-4">Code</h2>
<pre><code class="language-r">train_df = Hitters[31:nrow(Hitters),]

rf_mod = randomForest(Salary~ . , data = train_df, ntree = 10)
rf_mod

##
## Call:
##  randomForest(formula = Salary ~ ., data = train_df, ntree = 10)
##                Type of random forest: regression
##                      Number of trees: 10
## No. of variables tried at each split: 1
##
##           Mean of squared residuals: 182725.5
##                     % Var explained: 15.89
</code></pre>
<p>The variable that are used is only 1. I suppose the reason is that there are only 2 variables in the X train data. According to the rule of thumb, the number of splitted variable is K/3 for regression model. In our case it is 2/3, which is rounded to be 1.</p>
<p>Now we can feed the randomForest function with xtest and ytest so that we can get the MSE of the test set.</p>
<pre><code class="language-r">set.seed(100)
rf_mod = randomForest(Salary~ . , data = train_df,xtest = X_test ,ytest = y_test, ntree = 10)
rf_mod

## Call:
## randomForest(formula = Salary ~ ., data = train_df, xtest = X_test,      ytest = y_test, ntree = 10)
##               Type of random forest: regression
##                     Number of trees: 10
## No. of variables tried at each split: 1
##
##          Mean of squared residuals: 193201.2
##                    % Var explained: 11.06
##                       Test set MSE: 67380.79
##                    % Var explained: 24.66



cat(&quot;random forest RMSE of test set =&quot;, sqrt(67380.79))

## random forest RMSE of test set = 259.5781
</code></pre>
<p>After reading the XG boosting documentation, I assume the parameter nrounds control the number of the tree therefore I set it to be 10 to make it comparable with the previous results.</p>
<pre><code class="language-r">xgb = xgboost(data = data.matrix(X_train), label = y_train,
              max.depth =5, eta = 1,
              nthread = 2, nrounds =10
       )

</code></pre>
<p>And the RMSE of the predictions can be calculated as follows:</p>
<pre><code class="language-r">
y_pred &lt;- predict(xgb, data.matrix(X_test))

cat(&quot;RMSE of xgboost = &quot;, sqrt(mean((y_pred - y_test)^2)) )
## RMSE of xgboost =  285.6745
</code></pre>
<p>The RMSE is bigger than the random forest model. It could be the reason that the sample size is not big enough or I did the tune the prameters in the function well. <br>
However, it is better than the bagged tree model.</p>
<h1 id="ending">Ending</h1>
<h2 id="challenges">Challenges</h2>
<p>Conceptually, tree based methods are not difficult to understand. However, depending on your background, it might be difficult to implement them by plain coding. For example when I was coding the tree growing algorithm, I was struggled with grasping m and M. And also it is easy to code the tree growing process when depth = 2 or 3 but it could be hard to generalize it. It requires a good understanding of looping. <br>
Nevertheless, the struggling process does help me to understand the algorithm better. I would encourage the reader to get your hand dirty by starting from scratch despite the fact that there are packages which can make it work easily.</p>
<h2 id="tips">Tips</h2>
<ul>
<li>The graphic illustration of how tree-based methods partitioning feature into a set of rectangles is pretty good. Please check out on <a href="(https://web.stanford.edu/~hastie/ElemStatLearn/)">ESL</a> P306.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Application of EM Algorithm]]></title>
        <id>https://BolinWu-Gridea.github.io/post/2021-02-03-EM_Post/</id>
        <link href="https://BolinWu-Gridea.github.io/post/2021-02-03-EM_Post/">
        </link>
        <updated>2021-02-02T09:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Expectation-maximization (EM) algorithm is a powerful unsupervised<br>
machine learning tool. Conceptually, It is quite similar to k-means<br>
algorithm, which I shared in this <a href="https://bolinwu.org/Kmeans/">post</a>.<br>
However, instead of clustering through estimated means, it cluster<br>
through estimating the distributions parameters and then evaluate how<br>
likely is each observation belong to distributions. Another difference<br>
is that EM uses soft assignment while k-means uses hard assignment.</p>
<p>The content includes:</p>
<ol>
<li>The procedure of EM algorithm in the<br>
two-component mixture model context.</li>
<li>How to apply different parts of<br>
the algorithm step-by-step by simulation data.</li>
<li>Test the algorithm by using data of <a href="https://web.stanford.edu/~hastie/ElemStatLearn/">Hastie et<br>
al. (2009)</a>, as well as<br>
the built-in <strong>faithful</strong> and <strong>iris</strong> dataset.</li>
<li>Algorithm evaluation.</li>
</ol>
<p>Prerequisite to read the following blog:</p>
<ul>
<li>Basic knowledge of mixture<br>
model, multivariate normal distribution, maximum likelihood.</li>
<li>R<br>
programming.</li>
</ul>
<p>Main reference:</p>
<ul>
<li><a href="https://web.stanford.edu/~hastie/ElemStatLearn/">The Elements of Statistical Learning by Hastie et<br>
al. (2009)</a> Chapter 8.</li>
<li>Mans Magnusson (2020). uuml: R Content for the Introduction to<br>
Machine Learning. Course at Uppsala University. R package version 0.2.0.</li>
</ul>
<h1 id="loading-r-packages-and-data">Loading R packages and data</h1>
<p>Loading the packages and the data that are used in this post.</p>
<pre><code class="language-r"># add this line for installing the uuml package
# remotes::install_github(&quot;MansMeg/IntroML&quot;,
#                        subdir = &quot;rpackage&quot;)

# load the package and data
library(ggplot2)
library(uuml)
data(&quot;mixture_data&quot;)
y =  mixture_data
data(&quot;iris&quot;)
data(&quot;faithful&quot;)
</code></pre>
<h1 id="algorithm-procedure">Algorithm Procedure</h1>
<p>In the context of simple two-component mixture model, we would like to model the density of given data by two normal distributions:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>Y</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∼</mo><mi mathvariant="normal">N</mi><mo>(</mo><msub><mi>μ</mi><mn>1</mn></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mn>1</mn><mn>2</mn></msubsup><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>Y</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∼</mo><mi mathvariant="normal">N</mi><mo>(</mo><msub><mi>μ</mi><mn>2</mn></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mn>2</mn><mn>2</mn></msubsup><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>Y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi mathvariant="normal">Δ</mi><mo>)</mo><msub><mi>Y</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant="normal">Δ</mi><msub><mi>Y</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
Y_{1} &amp; \sim \mathrm{N}(\mu_{1},\sigma_{1}^{2}) \\
Y_{2} &amp; \sim \mathrm{N}(\mu_{2},\sigma_{2}^{2}) \\
Y &amp;= (1 - \Delta)Y_{1} + \Delta Y_{2}\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.548216em;vertical-align:-2.024108em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.524108em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.135892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.6358920000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.024108em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.524108em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.135892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathrm">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-1.6358920000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.024108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Where $$\Delta \in (0,1)$$ with  $$Pr (\Delta =1) = \pi$$.</p>
<p>Then the density of Y is</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>g</mi><mi>Y</mi></msub><mo>(</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>π</mi><mo>)</mo><msub><mi>ϕ</mi><msub><mi>θ</mi><mn>1</mn></msub></msub><mo>(</mo><mi>y</mi><mo>)</mo><mo>+</mo><mi>π</mi><msub><mi>ϕ</mi><msub><mi>θ</mi><mn>2</mn></msub></msub><mo>(</mo><mi>y</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
g_{Y}(y) = (1 - \pi) \phi_{\theta_{1}}(y) + \pi \phi_{\theta_{2}}(y)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5000000000000002em;vertical-align:-0.5000000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5000000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Where $$\phi_{\theta}(x)$$ denotes the normal density with parameters $$\theta = (\mu,\sigma^{2})$$.</p>
<p>And the log-likelihood  on the N training cases of data Z is given by</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>l</mi><mo>(</mo><mi>θ</mi><mo separator="true">;</mo><mi>Z</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>l</mi><mi>o</mi><mi>g</mi><mo>[</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>π</mi><mo>)</mo><msub><mi>ϕ</mi><msub><mi>θ</mi><mn>1</mn></msub></msub><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><mi>π</mi><msub><mi>ϕ</mi><msub><mi>θ</mi><mn>2</mn></msub></msub><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>)</mo><mo>]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
l(\theta; Z) = \sum_{i=1}^{N} log [ (1 - \pi) \phi_{\theta_{1}}(y_{i}) + \pi \phi_{\theta_{2}}(y_{i}) ]
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.4060050000000004em;vertical-align:-1.4530025em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9530025000000004em;"><span style="top:-3.9530025em;"><span class="pstrut" style="height:3.828336em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4530025em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Direct maximization of $$l(\theta; Z)$$ is not feasible numerically therefore we proceed it in an iterative way. A more dedicated deduction is available in the reference book.<br>
In short, what we do here is to estimate $$\pi$$ by</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>γ</mi><mi>i</mi></msub><mo>(</mo><mi>θ</mi><mo>)</mo><mo>=</mo><mi>P</mi><mi>r</mi><mo>(</mo><msub><mi mathvariant="normal">Δ</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>θ</mi><mi>Z</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\gamma_{i}(\theta) =Pr(\Delta_{i} = 1 | \theta Z)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5000000000000002em;vertical-align:-0.5000000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5000000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 20: …ma_{i}(\theta) $̲$ is also calle…'>\gamma_{i}(\theta) $$ is also called the **responsibility** of model 2 for observation i.

The EM algorithm consists of three  steps:
1. Initial guesses for the parameters $$\hat{\mu_{1}}$$, $$\hat{\sigma_{1}}^{2}$$,  $$\hat{\mu_{2}}$$, $$\hat{\sigma_{2}}^{2}$$, $$\hat{\pi}$$.
2. **Expectation Step:** compute the responsibilities
</p>
<p>\begin{aligned}<br>
\hat{\gamma_{i}} = \frac{\hat{\pi} \phi_{\hat{\theta_{2}}}(y_{i})}{ (1 - \hat{\pi}) \phi_{\hat{\theta_{1}}}(y_{i}) + \hat{\pi}\phi_{\hat{\theta_{2}}}(y_{i})}, i = 1,2,...,N<br>
\end{aligned}</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3.</mn><mo>∗</mo><mo>∗</mo><mi>M</mi><mi>a</mi><mi>x</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>z</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo>:</mo><mo>∗</mo><mo>∗</mo><mo>:</mo><mi>U</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>v</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">3. **Maximization Step:** : Update the means and variances:
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span></span></p>
<p>\begin{aligned}<br>
\hat{\mu_{1}} &amp;= \frac{\sum_{i=1}^{N} (1 - \hat{\gamma_{i}})y_{i}}{\sum_{i = 1}^{N}\hat{\gamma_{i}}} \<br>
\hat{\mu_{2}} &amp;= \frac{\sum_{i=1}^{N} \hat{\gamma_{i}}y_{i}} {\sum_{i = 1}^{N}\hat{\gamma_{i}}} \<br>
\hat{\sigma_{1}} &amp;= \frac{\sum_{i=1}^{N} (1 - \hat{\gamma_{i}})(y_{i}-\hat{\mu_{1}})^{2}}{\sum_{i = 1}^{N}(1 -\hat{ \gamma_{i}})} \<br>
\hat{\sigma_{2}} &amp;= \frac{\sum_{i=1}^{N}  \hat{\gamma_{i}}(y_{i}-\hat{\mu_{2}})^{2}}{\sum_{i = 1}^{N}\hat{ \gamma_{i}}} \<br>
\hat{\pi} &amp;= \sum_{i = 1}^{N}\frac{\hat{\gamma_{i}}}{N}<br>
\end{aligned}</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 350: …n(n, theta){
  #̲ simulate y1 an…'>4. Iterate step 2 and 3 until convergence.


A Scratch of Mixture model
==========================

Now, let us proceed and grasp the concepts mentioned above more clearly
with code and data.

(1) Implement a function to simulate data from a univariate mixture model by mixture model as mentioned above.

``` r
r_uni_two_com = function(n, theta){
  # simulate y1 and y2 according to the equations mentioned above
  y1 = rnorm(n,theta$mu_1,theta$sigma_1)
  y2 = rnorm(n,theta$mu_2,theta$sigma_2)
  # mixed
  y = (1 - theta$pi) * y1 + theta$pi * y2
  return(y)
}
```

(2) Simulate 200 observations using $$\mu_1=-2$$, $$\mu_2=1.5$$, $$\sigma_1=2 $$, $$ \sigma_2=1 $$ and $$\pi=0.3$$. Visualize observations in a histogram.

``` r
n = 200
theta_0 = list(mu_1 = -2, mu_2 = 1.5, sigma_1 = 2, sigma_2 = 1, pi = 0.3)
set.seed(2020)
simulation_data = r_uni_two_com(n,theta_0)
hist(x = simulation_data, main = &quot;Histgram of Simulated Data of Mixture Model&quot;, xlab = &quot;Mixed Y&quot;)
```

&lt;img src=&quot;{{ site.url }}{{ site.baseurl }}/images/2021-02-03-EM_Post_files/figure-markdown_github/unnamed-chunk-2-1.png&quot; alt=&quot;unknown&quot;&gt;

(3) Compute the density value for a given set of parameters and data with a function $$d\_uni\_two\_comp(x, \theta)$$.

``` r
# get the density by using dnorm() function
d_uni_comp = function(x,theta){
  density_m1 = dnorm(x,theta$mu_1,theta$sigma_1)
  density_m2 = dnorm(x, theta$mu_2,theta$sigma_2)
  return(list(density_m1 = density_m1,density_m2 = density_m2 ))
}

library(reshape2) # for merging the density plots
# melt the density into one column so that we can plot them in one figure
data&lt;- melt(d_uni_comp(simulation_data,theta_0) )
# combine the it with simulation data
data = cbind(simulation_data,data)
ggplot(data,aes(x=simulation_data,y = value, color=L1)) + geom_line(alpha=0.7)+ theme_minimal() + ggtitle(&quot;Simutated Data versus Corresponding Density&quot;) +
  theme(plot.title = element_text(hjust = 0.5),legend.title = element_blank()) +
  coord_cartesian(xlim =c(-4,4))
```

&lt;img src=&quot;{{ site.url }}{{ site.baseurl }}/images/2021-02-03-EM_Post_files/figure-markdown_github/unnamed-chunk-3-1.png&quot; alt=&quot;unknown&quot;&gt;

Model 1 (red line) seems to be centered around -2 and model 2 (blue line) seems to be centered around 2. It looks reasonable according to the data generation process.

(4) Calculate $$\gamma$$ at the **expectation** step.

Here the function $$e\_uni\_two\_comp(X, theta)$$ returns a vector of gamma for each row in **X**.


``` r
# use equation above to calculate the resposibility
e_uni_two_camp = function(x,theta){
  gamma_i =( theta$pi * d_uni_comp(x,theta)$density_m2 ) /
    ( (1-theta$pi) * d_uni_comp(x,theta)$density_m1 +
        theta$pi * d_uni_comp(x,theta)$density_m2  )
  return(gamma_i)
}

# initial guess of parameters
theta_0 = list(mu_1 = 4.12, mu_2 = 0.94, sigma_1 = 2, sigma_2 = 2, pi = 0.5)
gamma = e_uni_two_camp(y,theta_0)
head(gamma)
```

    ##           [,1]
    ## [1,] 0.9106339
    ## [2,] 0.8716861
    ## [3,] 0.7797225
    ## [4,] 0.6645640
    ## [5,] 0.6484311
    ## [6,] 0.5178799

Initially, $$\mu_1$$ = 4.12, $$\mu_2$$ = 0.94, $$\sigma_1$$ = 2, $$\sigma_2$$ = 2. According to the definition of responsibility, the larger responsibility ( $$\gamma$$ ) of a given x, the more likely it is belong to model 2, otherwise it may more likely to belong to model 1.
For example, we can see that the first 6 observations, the responsibilities are bigger than 0.5, so they are likely belong to model 2. However, we need to continue on iterating the process until it converges.

(5) Implement a function called $$max\_uni\_two\_comp(X, gamma)$$ that returns a list with parameters mu1, mu2, sigma1, sigma2 and pi at the **maximization** step.

``` r
max_uni_two_comp = function(y,gamma){
  mu_1 = sum( (1 - gamma) * y ) / sum( 1 - gamma)
  mu_2 = sum( ( gamma) * y ) / sum(  gamma)
  sigma_1 =  sum( (1 - gamma) * ((y-mu_1)^2) ) / sum( 1 - gamma)
  sigma_2 = sum( ( gamma) * (y-mu_2)^2 ) / sum( gamma)
  pi = sum(gamma)/ length(y)
  return(list(mu_1 = mu_1, mu_2 = mu_2, sigma_1 = sqrt(sigma_1),
              sigma_2 = sqrt(sigma_2), pi = pi))
}

theta = max_uni_two_comp(y,gamma)
theta
```

    ## $mu_1
    ## [1] 3.842941
    ##
    ## $mu_2
    ## [1] 1.450413
    ##
    ## $sigma_1
    ## [1] 1.700666
    ##
    ## $sigma_2
    ## [1] 1.47168
    ##
    ## $pi
    ## [1] 0.4883709

These are the estimated parameters after the first iteration.

(6) Now we need to implement the log-likelihood of the model as $$ll\_uni\_two\_comp(x, theta)$$.
Log-likelihood is important when evaluating the algorithm.

``` r
ll_uni_two_camp = function(x,theta){
  ll_i =sum( log( ( (1 - theta$pi) * d_uni_comp(x,theta)$density_m1 ) +
                    (theta$pi * d_uni_comp(x,theta)$density_m2) )  )
  return(ll_i)
}
ll_uni_two_camp(y,theta_0)
```

    ## [1] -43.1055

(7) Combine the implemented functions to an EM algorithm $$em\_uni\_two\_comp(X, theta\_0, iter)$$ that takes in a $$n \times p$$ data matrix **X** and an initialization value for as $$theta\_0$$.

``` r
em_uni_two_comp = function(y,theta){
  iter = 3
  for (i in 1:iter) {
  gamma = e_uni_two_camp(y,theta)
  theta = max_uni_two_comp(y,gamma)
  ll = ll_uni_two_camp(y,theta)

  # print the log-likehood
  cat(&quot;Log Lik:&quot;,ll,&quot;\n&quot;)
}
}

em_uni_two_comp(y,theta_0)
```

    ## Log Lik: -41.53247
    ## Log Lik: -41.11211
    ## Log Lik: -40.48348

Here the iteration is set to be 3 and we can see that the log likelihood is getting smaller which is as expected.

Test the algorithm on the y for 20 iterations and get the $$\hat{\pi}$$.

``` r
for (iter in c(1,5,10,15,20)) {
  # iter = 20
  # intial gamma
  gamma = e_uni_two_camp(y,theta_0)
  # start the iteration of EM
  for (i in 1:iter) {
  theta = max_uni_two_comp(y,gamma)
  ll = ll_uni_two_camp(y,theta)
  gamma = e_uni_two_camp(y,theta)
}
cat(&quot;iteration=&quot;,iter,&quot;;&quot;,&quot;estimated pi = &quot;,theta$pi, &quot;\n&quot;)
}
```

    ## iteration= 1 ; estimated pi =  0.4883709
    ## iteration= 5 ; estimated pi =  0.4981389
    ## iteration= 10 ; estimated pi =  0.5436594
    ## iteration= 15 ; estimated pi =  0.5532677
    ## iteration= 20 ; estimated pi =  0.5544302


# Evaluation

Next we can evaluate EM algorithm by plotting the change of log likeliood to see if it converges.

``` r
estimated_final_ll =c()
  iter = 20
  # intial gamma
  gamma = e_uni_two_camp(y,theta_0)
  # start the iteration of EM
  for (i in 1:iter) {
  theta = max_uni_two_comp(y,gamma)
  ll = ll_uni_two_camp(y,theta)
  gamma = e_uni_two_camp(y,theta)
  estimated_final_ll = cbind(estimated_final_ll,ll)
}


plot(estimated_final_ll[1,],
     ylab = &quot;observed Data Log-Likelihood&quot;,
     xlab = &quot;iteration&quot;,
     main = &quot;Estimated Log-likelihood over Iterations&quot;)
```


&lt;img src=&quot;{{ site.url }}{{ site.baseurl }}/images/2021-02-03-EM_Post_files/figure-markdown_github/unnamed-chunk-9-1.png&quot; alt=&quot;unknown&quot;&gt;

The trend looks converged after iteration = 10. Therefore the algorithm is working well for the given dataset.

# Run the EM algorithm with the other dataset.

Here I set the iteration to be 20. The estimated parameters will be
printed under the code.  

## Eruptions variable of Faithful dataset:


``` r
erruptions = faithful$eruptions
# initial guess of parameters
theta_erup = list(mu_1 = 1.75, mu_2 = 4.5, sigma_1 = 1, sigma_2 = 1, pi = 0.55)

estimated_final_ll =c()
  iter = 20
  # intial gamma
    gamma = e_uni_two_camp(erruptions,theta_erup )
  # start the iteration of EM
  for (i in 1:iter) {
  theta_faithful = max_uni_two_comp(erruptions,gamma)
  ll = ll_uni_two_camp(erruptions,theta)
  gamma = e_uni_two_camp(erruptions,theta)
  }
theta_faithful
```

    ## $mu_1
    ## [1] 4.256629
    ##
    ## $mu_2
    ## [1] 2.05479
    ##
    ## $sigma_1
    ## [1] 0.4899172
    ##
    ## $sigma_2
    ## [1] 0.3383707
    ##
    ## $pi
    ## [1] 0.3491834

## Petal.Length variable of Iris dataset:


``` r
pd_length = iris$Petal.Length
estimated_final_ll =c()
# set the initial parameters
theta_iris = list(mu_1 =1, mu_2 = 4, sigma_1 = 1, sigma_2 = 1, pi = 0.5)
  iter = 20
  # intial gamma
    gamma = e_uni_two_camp(pd_length,theta_iris )
  # start the iteration of EM
  for (i in 1:iter) {
  theta_iris = max_uni_two_comp(pd_length,gamma)
  ll = ll_uni_two_camp(pd_length,theta)
  gamma = e_uni_two_camp(pd_length,theta)
  }
theta_iris
```

    ## $mu_1
    ## [1] 4.919392
    ##
    ## $mu_2
    ## [1] 1.502265
    ##
    ## $sigma_1
    ## [1] 0.8159113
    ##
    ## $sigma_2
    ## [1] 0.3266122
    ##
    ## $pi
    ## [1] 0.3398739

## Visualize the density for the two datasets using the parameters estimated with EM algorithm.

### First visualize for the faithful dataset

``` r
data&lt;- melt(d_uni_comp(erruptions,theta_faithful))
# combine the it with simulation data
data = cbind(erruptions,data)

ggplot(data,aes(x=erruptions,y = value, color=L1)) + geom_line(alpha=0.7)+ theme_minimal() + ggtitle(&quot;Density for Erruptions after Estimated by EM Algorithm&quot;) +theme(plot.title = element_text(hjust = 0.5),legend.title = element_blank())
```

&lt;figure&gt;
  &lt;img src=&quot;{{ site.url }}{{ site.baseurl }}/images/ML/erruption-density.png&quot; alt=&quot;unknown&quot; style=&quot;width:100%&quot;&gt;
  &lt;figcaption&gt; EM estimated density of faithful data &lt;/figcaption&gt;
&lt;/figure&gt;

### Then visualize for the iris dataset

``` r
data&lt;- melt(d_uni_comp(pd_length,theta_iris))
# combine the it with simulation data
data = cbind(pd_length,data)

ggplot(data,aes(x=pd_length,y = value, color=L1)) + geom_line(alpha=0.7)+ theme_minimal() + ggtitle(&quot;Density for Pedal Length after Estimated by EM Algorithm&quot;) +theme(plot.title = element_text(hjust = 0.5),legend.title = element_blank())
```

&lt;figure&gt;
  &lt;img src=&quot;{{ site.url }}{{ site.baseurl }}/images/ML/iris-density.jpeg&quot; alt=&quot;unknown&quot; style=&quot;width:100%&quot;&gt;
  &lt;figcaption&gt;EM estimated density of iris data &lt;/figcaption&gt;
&lt;/figure&gt;


These clustering results looks reasonable. Great!


# Conclusion
This post shared how to derive the basic pieces of EM algorithm in the two-component mixture model case. We can see in the end the algorithm gives us the a mixture distribution based on the given dataset instead of telling directly which observations belong to which cluster.\
In the future I will share how to use EM algorithm in general.

Thank you for reading!
</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://BolinWu-Gridea.github.io/post/hello-gridea/</id>
        <link href="https://BolinWu-Gridea.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>